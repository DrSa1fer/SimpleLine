# Команды

---
## 1. Зависимости
---

### Пространства имен
Все необходимые для регистрации команд атрибуты находится в пространстве имен ``SimpleLineLibrary.Setup``.
### Типы
- ``[CommandDefinitions]`` - нужен для определения групп команд.
- ``[Command]`` - нужен для определения команды. 
- ``[Description]`` - нужен для добавления описания к команде или параметру. 
- ``[CustomKeys]`` - нужен для установки своих собственных ключей параметров.

---
## 2. Именование
---

Имя команды может содержать ``Буквы``, ``Цифры``, "``-``", но должно начинаться с  ``Буквы``.
Примеры:
- ``make`` 
- ``t123``
- ``new-file``

---
## 3. Объявление
---

### Подготовка
Нам следует подготовить класс и реализовать в нем методы. Для примера, создадим класс ``MyCommand`` и реализуем в нем метод ``Say``. 
Это выглядит так:

```csharp
public class MyCommand
{
    public void Say(string msg)
    {
        Console.WriteLine($"I say: {msg}");
    }
}
```

> [!WARNING]
> Классы и методы должен быть с публичным модификаторами доступа - ``public``, иначе они будут попросту недоступны для SimpleLine

### Добавление атрибутов
В классе, который мы определили, добавим несколько новых строчек.

##### - Добавляем пространство имен
В нем содержится определение нужных нам атрибутов.
```csharp 
using SimpleLineLibrary.Setup;
```
##### - Помечаем класс атрибутом ``[CommandDefinitions]``
Это нужно для того, чтобы в дальнейшем система знала, что в этом классе могут быть определения команд.
```csharp
[CommandDefinitions]
public class MyCommand { ... }
```
##### - Помечаем метод атрибутом ``[Command]``
Это нужно для того, чтобы система могла использовать метод как команду и даем имя, по которому она будет доступна.
```csharp 
[Command("say")]
public void Say(string msg) { ... }
```

---
## 4. Дополнительно
---

##### Помечаем метод атрибутом ``[Description]``
Это нужно для того, чтобы система получила описание команды и вывести его при необходимости. 
В случае, если атрибут не применен, описание будет пустым.
```csharp 
[Command("say")]
[Description("Command print your message")]
public void Say(string msg) { ... }
```
##### Помечаем параметр метода атрибутом ``[Description]``
Это нужно для того, чтобы система получила описание команды и вывести его при необходимости.
В случае, если атрибут не применен, описание будет пустым.
```csharp 
[Command("say")]
[Description("Command print your message")]
public void Say([Description("Your message")] string msg) { ... }
```
##### Помечаем параметр метода атрибутом ``[CustomKeys("-m", "--msg")]``
Это нужно для того, чтобы указывать свои ключей параметров, которые будут использоваться во время получения значений.
В случае, если атрибут не применен, ключи будут созданы автоматически.
```csharp 
[Command("say")]
[Description("Command print your message")]
public void Say([Description("Your message")] [CustomKeys("-m", "--msg")] string msg) { ... }
```

---
## 5. Вложенные команды 
---

Команды могут быть вложенными в другую команду для примера возьмем ``math``, мы хотим добавить в нее вложенну команду, чтобы получить ``math sum``. Для этого нам понадобится при объявлении команды передать имена команд через пробел от старшей к младшей:
```csharp
[Command("math sum")]
public void Sum(int x, int y) { ... }
```
Или воспользоваться группировкой. Подробнее в следующем пункте

---
## 6. Группировка
---

Для понимания зачем это нужно нам стоит рассмотреть пример.
Возьмем пример с командой ``math`` и вложенной командой ``sum``:
```csharp
public class MathCommands
{
    public void Math()
    {
        Console.WriteLine("Math is cool!");
    }

    public void Sum(int x, int y)
    {
        Console.WriteLine($"Result: {x + y}");
    }
}
```

Первый вариант решения задачи, вероятнее всего, который вы бы использовали:

```csharp
using SimpleLineLibrary.Setup;

[CommandDefinitions]
public class MathCommands
{
    [Command("math")]
    public void Math() { ... }

    [Command("math sum")]
    public void Sum(int x, int y) { ... }
}
```
В том варианте все верно, но можно упростить. Давайте применим группировку. Для этого в атрибуте ``[CommandDefinitions]`` есть перегрузка, которая принимает имя команды к которой надо прикрепиться. Вот тот же код. работающий точно также, что и в прошлом примере, но на этот раз с использованием группировки:
```csharp
using SimpleLineLibrary.Setup;

[CommandDefinitions("math")]
public class MathCommands
{
    [Command("@")]
    public void Math() { ... }

    [Command("sum")]
    public void Sum(int x, int y) { ... }
}
```
> Это становить более актуальным, когда глубина вложенности растет

Символ ``@`` - это контекстная функция библиотеки, позволяющая дать определение команде, к которой привязана группа, в данном случае ``math``.